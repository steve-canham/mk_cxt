use sqlx::{Pool, Postgres};
use crate::AppError;
use log::info;

pub async fn create_city_names_table(pool: &Pool<Postgres>) -> Result<(), AppError> {

    let sql = r#"drop table if exists locs.city_names;
            create table locs.city_names
            ( 
                  id                    int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1000001 INCREMENT BY 1) NOT NULL
                , comp_name             varchar
                , city_id               int
                , city_name             varchar
                , disamb_id             int
                , disamb_name           varchar
                , country_id            int
                , country_name          varchar
                , source                varchar
            );
            create index city_name_comp_name on locs.city_names(comp_name);
            create index city_name_name on locs.city_names(city_name);"#;

    sqlx::raw_sql(sql).execute(pool)
            .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;
    Ok(())
}


pub async fn transfer_city_names_to_mdr(pool: &Pool<Postgres>) -> Result<(), AppError> {

    let sql = r#"insert into locs.city_names (comp_name, city_id, city_name, disamb_id, 
            disamb_name, country_id, country_name, source) 
            select lower(replace(alt_name,'.', '')), city_id, city_name, disamb_id, 
            disamb_name, country_id, country_name, 'geonames'
            from ftw_geo.city_names"#;

    let res = sqlx::raw_sql(sql).execute(pool)
    .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;   
    info!("{} city name records transferred to locs schema", res.rows_affected()); 

    Ok(())
}


pub async fn make_mdr_related_changes_1(pool: &Pool<Postgres>) -> Result<(), AppError> {

    // Below are MDR specific related changes, to support better matching....

    // to avoid some very strange city allocations

    let sql = r#"delete from locs.city_names where comp_name = 'chicago' and disamb_name = 'Ohio';
    delete from locs.city_names where comp_name = 'new york' and disamb_name = 'Nebraska';"#;

    sqlx::raw_sql(sql).execute(pool)
    .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;    

    // to add some additional city names used within the mdr

    let params_set: Vec<Vec<&str>> = vec![
            vec!["bucuresti", "Bucharest", "Romania", "bucharest"], 
            vec!["besancon", "Besançon", "France", "besançon"], 
            vec!["clermont ferrand", "Clermont-Ferrand", "France", "clermont-ferrand"],
            vec!["tubingen", "Tübingen", "Germany", "tübingen"], 
            vec!["wuerzburg", "Würzburg", "Germany", "würzburg"], 
            vec!["luebeck", "Lübeck", "Germany", "lübeck"], 
            vec!["munchen", "Munich", "Germany", "munich"], 
            vec!["kanagawa", "Yokohama", "Japan", "yokohama"], 
            vec!["saint-petersburg", "Saint Petersburg", "Russia", "saint petersburg"],
            vec!["caba", "Buenos Aires", "Argentina", "buenos aires"], 
            vec!["ciudad autonoma de buenos aires", "Buenos Aires", "Argentina", "buenos aires"], 
    ];

    add_city_recs(params_set, pool).await?;

    let params_set: Vec<Vec<&str>> = vec![
            vec!["new york", "New York City", "United States", "new york city"], 
            vec!["saint-petersburg", "St. Petersburg", "United States", "saint petersburg"], 
            vec!["plano", "Dallas", "United States", "dallas"], 
            vec!["temple", "Dallas", "United States", "dallas"], 
            vec!["newport beach", "Irvine", "United States", "irvine"], 
            vec!["royal oak", "Detroit", "United States", "detroit"], 
        ];

        add_city_recs(params_set, pool).await?;

        let sql = r#"insert into locs.city_names(comp_name, city_id, city_name, disamb_id, disamb_name, country_id, country_name, source)
                    select 'hershey', city_id, city_name, disamb_id, disamb_name, country_id, country_name, 'mdr'
                    from locs.city_names 
                    where city_id = 5192726 and comp_name = 'harrisburg';

                    insert into locs.city_names(comp_name, city_id, city_name, disamb_id, disamb_name, country_id, country_name, source)
                    select 'chapel hill', city_id, city_name, disamb_id, disamb_name, country_id, country_name, 'mdr'
                    from locs.city_names 
                    where city_id = 4464368  and comp_name = 'durham';"#;

        sqlx::raw_sql(&sql).execute(pool)
             .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    Ok(())
}


pub async fn make_mdr_related_changes_2(pool: &Pool<Postgres>) -> Result<(), AppError> {

    let params_set: Vec<Vec<&str>> = vec![
        vec!["prague 2", "Prague", "Czechia", "prague"], 
        vec!["praha 2", "Prague", "Czechia", "prague"], 
        vec!["praha 3", "Prague", "Czechia", "prague"], 
        vec!["praha 4", "Prague", "Czechia", "prague"], 
        vec!["praha 5", "Prague", "Czechia", "prague"], 
        vec!["praha 6", "Prague", "Czechia", "prague"], 
        vec!["praha 8", "Prague", "Czechia", "prague"], 
        vec!["praha 10", "Prague", "Czechia", "prague"], 
        vec!["temple", "Hradec Králové", "Czechia", "hradec králové"], 
    ];

    add_city_recs(params_set, pool).await?;

    let params_set: Vec<Vec<&str>> = vec![
        vec!["frankfurt-oder", "Frankfurt (Oder)", "Germany", "frankfurt (oder)"], 
        vec!["frankfurt / oder", "Frankfurt (Oder)", "Germany", "frankfurt (oder)"], 
        vec!["frankfurt oder", "Frankfurt (Oder)", "Germany", "frankfurt (oder)"], 
        vec!["frankfurt, oder", "Frankfurt (Oder)", "Germany", "frankfurt (oder)"], 
        vec!["frankfurt/ oder brandenburg", "Frankfurt (Oder)", "Germany", "frankfurt (oder)"], 
    ];

    add_city_recs(params_set, pool).await

}


pub async fn make_mdr_related_changes_3(pool: &Pool<Postgres>) -> Result<(), AppError> {

    let params_set: Vec<Vec<&str>> = vec![
        vec!["frankfurt on the main", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt/ main", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt/a. m. -höchst", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt/höchst", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt/m", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt/m.", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["60590 frankfurt", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["D-60590 frankfurt", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt-am-main", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt-hochst", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt-main", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt (a.m.)", "Frankfurt am Main", "Germany", "frankfurt am main"], 
    ];
        
    add_city_recs(params_set, pool).await?;

    let params_set: Vec<Vec<&str>> = vec![
        vec!["frankfurt (main)", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt / main", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt /main", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt a main", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt a. m", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt a. main", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt a.m.", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt a.m. hochst", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt a/m", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt am m.", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt a main Hessen", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt am main,", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt am mein", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt hoechst", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt m", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt main,", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        vec!["frankfurt n/a", "Frankfurt am Main", "Germany", "frankfurt am main"], 
        
    ];

    add_city_recs(params_set, pool).await

}


pub async fn add_city_recs(params: Vec<Vec<&str>>, pool: &Pool<Postgres>) -> Result<(), AppError> {

    let mut sql = "".to_string();
    for p in params {
         
         let this_sql = r#"insert into locs.city_names(comp_name, city_id, city_name, disamb_id, disamb_name, country_id, country_name, source)
                "#.to_string()
                + &format!("select '{}', city_id, city_name, disamb_id, disamb_name, country_id, country_name, 'mdr'", p[0])
                + r#" 
                from locs.city_names 
                "#
                + &format!("where city_name = '{}' and country_name = '{}' and comp_name = '{}';", p[1], p[2], p[3])
                + r#"

                "#;

         sql.push_str(&this_sql);
    }

    sqlx::raw_sql(&sql).execute(pool)
             .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    Ok(())

}
